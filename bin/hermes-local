#!/usr/bin/env python

""" Command-line interface to Hermes."""

from __future__ import division

import argparse
import getpass
import logging
import sys

from sqlalchemy import desc

import hermes
from hermes import models
from hermes.models import Event, EventType, Host, Fate, Labor, Quest
from hermes.settings import settings

sa_log = logging.getLogger("sqlalchemy.engine.base.Engine")


def make_session():
    db_engine = models.get_db_engine(settings["database"], echo=False)
    models.Session.configure(bind=db_engine)
    return models.Session()


def list_event_types(args):
    logging.debug("list_event_types()")
    session = make_session()
    event_types = EventType.query().all()
    last_event_type = EventType.query().order_by(desc(EventType.id)).first()
    max_length = len(str(last_event_type.id))

    print"{}{}{}".format(
        str.ljust("ID", max_length + 3),
        str.ljust("CATEGORY", 20), str.ljust("STATE", 20)
    )
    for event_type in event_types:
        print "{}{}{}".format(
            str.ljust("[" + str(event_type.id) + "]", max_length + 3),
            str.ljust(event_type.category, 20), str.ljust(event_type.state, 20)
        )

    session.close()


def create_event_type(args):
    logging.debug("create_event_type({},{})", args.category, args.state)
    session = make_session()
    event_type = EventType.create(
        session, args.category, args.state, args.description
    )
    if event_type:
        print "Created event type {}".format(event_type.id)
        session.commit()
    else:
        print "Error creating event type."

    session.close()


def list_fates(args):
    logging.debug("list_fates()")
    session = make_session()
    fates = Fate.query().all()
    print "FATES  ([id] created by => completed by)\n "
    for fate in fates:
        creation_event = fate.creation_event_type
        completion_event = fate.completion_event_type
        print "[{}] {} => {}".format(
            fate.id,
            creation_event.category + "-" + creation_event.state,
            completion_event.category + "-" + completion_event.state
        )
        print fate.description
        print ""
    session.close()


def create_fate(args):
    logging.debug("create_fates()")
    if not args.ct and not (args.cc and args.cs):
        print (
            "To create a fate, you must specify either --creation-type,\nor "
            "--creation-category and creation-state."
        )
        return
    if not args.xt and not (args.xc and args.xs):
        print (
            "To create a fate, you must specify either --completion-type,\nor "
            "--completion-category and completion-state."
        )
        return

    session = make_session()
    if args.cc and args.cs:
        creation_event_type = EventType.get_event_type(
            session, args.cc, args.cs
        )
    else:
        creation_event_type = session.query(EventType).get(args.ct)

    if not creation_event_type:
        print "Creation event type not found."
        return

    if args.xc and args.xs:
        completion_event_type = EventType.get_event_type(
            session, args.xc, args.xs
        )
    else:
        completion_event_type = session.query(EventType).get(args.xt)

    if not completion_event_type:
        print "Completion event type not found."
        return

    fate = Fate.create(
        session, creation_event_type, completion_event_type,
        intermediate=args.intermediate,
        description=args.description
    )

    if fate:
        print "Create fate {}".format(fate.id)
        session.commit()
    else:
        print "Error creating fate."

    session.close()


def list_hosts(args):
    logging.debug("list_hosts()")
    session = make_session()
    hosts = Host.query().all()
    print "HOSTS:"
    for host in hosts:
        print "{}".format(host.hostname)
    session.close()


def add_host(args):
    logging.debug("add_host(%s)", args.hostname)
    session = make_session()
    host = Host.get_host(session, args.hostname)
    if host is None:
        Host.create(session, args.hostname)
        print "Created host {}".format(args.hostname)
        session.commit()
    else:
        print "Host {} already exists".format(args.hostname)
    session.close()


def list_host_events(args):
    logging.debug("list_host_events(%s)", args.hostname)
    session = make_session()
    host = Host.get_host(session, args.hostname)
    if host is None:
        logging.error("Could not find hostname %s", args.hostname)
        return

    events = (
        host.get_latest_events().limit(args.limit)
        .from_self().order_by(Event.timestamp).all()
    )

    print "EVENTS FOR {}:".format(host.hostname)
    for event in events:
        print "{}  {} {}  {}".format(
            event.timestamp, event.event_type.category,
            event.event_type.state, event.note
        )


def list_host_labors(args):
    logging.debug("list_host_labors(%s)", args.hostname)
    session = make_session()
    host = Host.get_host(session, args.hostname)
    if host is None:
        logging.error("Could not find hostname %s", args.hostname)
        return

    labors = host.get_open_labors().limit(args.limit).all()

    print "OPEN ACHIEVEMENTS FOR {}:".format(host.hostname)
    for labor in labors:
        print "{} created by event {} {}  {}".format(
            labor.creation_time,
            labor.creation_event.event_type.category,
            labor.creation_event.event_type.state,
            labor.creation_event.note or ""
        )


def create_event(args):
    logging.debug("create_event()")
    logging.debug(
        "host: %s    category: %s    state: %s    note: %s",
        args.hostname, args.category, args.state, args.note
    )

    session = make_session()

    event_type = EventType.get_event_type(session, args.category, args.state)

    if event_type is None:
        logging.error(
            "No matching event state found for %s %s", args.category, args.state
        )
        session.close()
        return

    host = Host.get_host(session, args.hostname)

    if host is None:
        host = Host.create(session, args.hostname)

    user = getpass.getuser()

    event = Event.create(session, host, user, event_type, args.note)

    if event:
        print "Event created: {} => {} {}".format(
            host.hostname, event_type.category, event_type.state
        )
        session.commit()
    else:
        print "Event creation failed."
        session.rollback()

    session.close()


def list_quests(args):
    logging.debug("list_quests()")
    session = make_session()

    quests = Quest.get_open_quests(session).all()

    print "QUESTS:"
    for quest in quests:
        print "[{}] {} by {}.  Embarked on {}".format(
            quest.id, quest.description, quest.creator, quest.embark_time
        )

        labors_remaining = 0
        for labor in quest.labors:
            if labor.completion_time is None:
                labors_remaining += 1

        total_labors = len(quest.labors)
        print "{:.2%} complete.  {} total labors.  {} remain open.\n".format(
            (total_labors - labors_remaining)/total_labors,
            total_labors,
            labors_remaining
        )

    session.close()


def show_quest(args):
    logging.debug("show_quest(%d)", args.quest_id)
    session = make_session()

    quest = session.query(Quest).get(args.quest_id)

    max_width = 0
    for labor in quest.labors:
        if len(labor.host.hostname) > max_width:
            max_width = len(labor.host.hostname)

    remaining = []
    completed = []
    for labor in quest.labors:
        if labor.completion_time is None:
            remaining.append(labor)
        else:
            completed.append(labor)

    if not args.list_only:
        print "QUEST {}:".format(args.quest_id)
        print "{} by {}.  Embarked on {}".format(
            quest.description, quest.creator, quest.embark_time
        )

        if args.all or args.completed_only:
            for labor in completed:
                print "{} achieved {} {} on {}".format(
                    labor.host.hostname.rjust(max_width + 4),
                    labor.creation_event.event_type.category,
                    labor.creation_event.event_type.state,
                    labor.completion_time
                )
        if not args.completed_only:
            for labor in remaining:
                print "{} must achieve {} {}".format(
                    labor.host.hostname.rjust(max_width + 4),
                    labor.creation_event.event_type.category,
                    labor.creation_event.event_type.state
                )

        total_labors = len(quest.labors)
        labors_remaining = len(remaining)
        labors_completed = len(completed)
        print "{:.2%} complete.  {} total labors.  {} remain open.\n".format(
            labors_completed/total_labors,
            total_labors,
            labors_remaining
        )
    else:
        if args.completed_only or args.all:
            for labor in completed:
                print labor.host.hostname
        if not args.completed_only:
            for labor in remaining:
                print labor.host.hostname

    session.close()


def create_quest(args):
    logging.debug("create_quest()")
    logging.debug(
        "category: %s    state: %s    note: %s",
        args.category, args.state, args.note
    )

    session = make_session()

    print "Creating quest... (could take some time)"

    hosts = []

    if args.hosts:
        for hostname in args.hosts.split(","):
            if not hostname:
                continue
            logging.debug("Specified host: %s", hostname)
            host = Host.get_host(session, hostname)
            if host is None:
                Host.create(session, hostname)
            hosts.append(hostname)
    else:
        for hostname in sys.stdin.read().split("\n"):
            if not hostname:
                continue
            logging.debug("Entered host: %s", hostname)
            host = Host.get_host(session, hostname)
            if host is None:
                Host.create(session, hostname)
            hosts.append(hostname)

    if len(hosts) == 0:
        logging.error("No hosts specified")
        return

    event_type = EventType.get_event_type(session, args.category, args.state)
    if event_type is None:
        logging.error(
            "No matching event state found for %s %s", args.category, args.state
        )
        session.close()
        return

    user = getpass.getuser()

    quest = Quest.create(session, user, hosts, event_type, description=args.note)

    print "Quest {} created with {} labors".format(
        quest.id, len(quest.labors)
    )

    session.commit()
    session.close()


def parse_cli_args():
    description_msg = "Hermes CLI"
    parser = argparse.ArgumentParser(description=description_msg)

    parser.add_argument("-c", "--config", default="/etc/hermes/server.yaml",
                        help="Path to config file.")
    parser.add_argument("-v", "--verbose", action="count", default=0, help="Increase logging verbosity.")
    parser.add_argument("-q", "--quiet", action="count", default=0, help="Decrease logging verbosity.")
    parser.add_argument("-V", "--version", action="version",
                        version="%%(prog)s %s" % hermes.__version__,
                        help="Display version information.")

    subparsers = parser.add_subparsers()

    # event type command line parser
    event_type_parser = subparsers.add_parser(
        "event-type", help="Create and list event types"
    )
    event_type_subparser = event_type_parser.add_subparsers()
    # event type list command line parser
    event_type_list_parser = event_type_subparser.add_parser("list")
    event_type_list_parser.set_defaults(func=list_event_types)
    # event type create command line parser
    event_type_create_parser = event_type_subparser.add_parser("create")
    event_type_create_parser.add_argument(
        "category",
        help="Category of the new event type"
    )
    event_type_create_parser.add_argument(
        "state",
        help="State of the new event type"
    )
    event_type_create_parser.add_argument(
        "-d", "--description", required=True,
        help="Human readable description for this event type"
    )
    event_type_create_parser.set_defaults(func=create_event_type)

    # fate command line parser
    fate_parser = subparsers.add_parser(
        "fate", help="Create and list fates"
    )
    # fate list parser
    fate_subparser = fate_parser.add_subparsers()
    fate_list_subparser = fate_subparser.add_parser("list")
    fate_list_subparser.set_defaults(func=list_fates)
    # fate create parser
    fate_create_subparser = fate_subparser.add_parser("create")
    fate_create_subparser.add_argument(
        "-cc", "--creation-category", help="The category of the creation event type",
        dest="cc", type=str
    )
    fate_create_subparser.add_argument(
        "-cs", "--creation-state", help="The state of the creation event type",
        dest="cs", type=str
    )
    fate_create_subparser.add_argument(
        "-ct", "--creation-type", help="The ID of the creation type",
        dest="ct", type=str
    )
    fate_create_subparser.add_argument(
        "-cx", "--completion-category",
        help="The category of the completion event type",
        dest="xc", type=str
    )
    fate_create_subparser.add_argument(
        "-xs", "--completion-state", help="The state of the completion event type",
        dest="xs", type=str
    )
    fate_create_subparser.add_argument(
        "-xt", "--completion-type", help="The ID of the completion event type",
        dest="xt", type=str
    )
    fate_create_subparser.add_argument(
        "-i", "--intermediate", action="store_true",
        help="When flagged, this fate only creates a new labor if closing an existing one"
    )
    fate_create_subparser.add_argument(
        "--description", help="The human readable description of this fate",
        required=True
    )
    fate_create_subparser.set_defaults(func=create_fate)

    # Add host command line parser
    host_parser = subparsers.add_parser("host", help="Host level operations")
    host_subparser = host_parser.add_subparsers()
    # Host list parser
    host_list_parsers = host_subparser.add_parser("list")
    host_list_parsers.set_defaults(func=list_hosts)
    # Host add parser
    host_add_parser = host_subparser.add_parser("add")
    host_add_parser.add_argument("hostname")
    host_add_parser.set_defaults(func=add_host)
    # Host events parsers
    host_events_parser = host_subparser.add_parser("events")
    host_events_parser.add_argument("hostname")
    host_events_parser.add_argument(
        "-l", "--limit", default=20, type=int,
        help="Limit the number of events displayed"
    )
    host_events_parser.set_defaults(func=list_host_events)
    # Host labors parser
    host_labors_parser = host_subparser.add_parser("labors")
    host_labors_parser.add_argument("hostname")
    host_labors_parser.add_argument(
        "-l", "--limit", default=20, type=int,
        help="Limit the number of labors displayed"
    )
    host_labors_parser.set_defaults(func=list_host_labors)

    # events command line parser
    event_parser = subparsers.add_parser(
        "event", help="Create and list events"
    )
    event_subparser = event_parser.add_subparsers()
    event_create_parser = event_subparser.add_parser("create")
    event_create_parser.add_argument("hostname")
    event_create_parser.add_argument("category")
    event_create_parser.add_argument("state")
    event_create_parser.add_argument(
        "-n", "--note", type=str, help="Note to attach to the Event"
    )
    event_create_parser.set_defaults(func=create_event)

    # quest command line parser
    quest_parser = subparsers.add_parser(
        "quest", help="Create and list Quests"
    )
    quest_subparser = quest_parser.add_subparsers()
    # quest list parser
    quest_list_parser = quest_subparser.add_parser("list")
    quest_list_parser.set_defaults(func=list_quests)
    # quest show parser
    quest_show_parser = quest_subparser.add_parser("show")
    quest_show_parser.add_argument("quest_id")
    quest_show_list_options = quest_show_parser.add_mutually_exclusive_group()
    quest_show_list_options.add_argument(
        "--all", action="store_true",
        help="Show all associated labors"
    )
    quest_show_list_options.add_argument(
        "--completed", action="store_true", dest="completed_only",
        help="Show only completed labors"
    )
    quest_show_parser.add_argument(
        "--list", dest="list_only", action="store_true",
        help="Only output a list of hostnames with open labors"
    )
    quest_show_parser.set_defaults(func=show_quest)
    # quest creation parser
    quest_create_parser = quest_subparser.add_parser("create")
    quest_create_parser.add_argument("category")
    quest_create_parser.add_argument("state")
    quest_create_parser.add_argument(
        "-n", "--note", type=str, required=True,
        help="Note to attach to the Quest"
    )
    quest_create_parser.add_argument(
        "-s", "--hosts", type=str,
        help="Comma separated Hosts involved in this Quest"
    )
    quest_create_parser.set_defaults(func=create_quest)

    return parser.parse_args()


def main():
    args = parse_cli_args()
    settings.update_from_config(args.config)

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG, format=settings.log_format)
    elif args.quiet:
        logging.basicConfig(level=logging.ERROR, format=settings.log_format)
    else:
        logging.basicConfig(level=logging.INFO, format=settings.log_format)

    args.func(args)


if __name__ == "__main__":
    main()
