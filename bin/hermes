#!/usr/bin/env python

""" Command-line interface to Hermes."""

from __future__ import division

import argparse
from dateutil import parser, tz
import getpass
import logging
import requests
from requests.packages import urllib3
import sys
import textwrap
from time import sleep
import traceback


import hermes
from hermes.settings_client import settings

logging.getLogger("requests").setLevel(logging.WARNING)
urllib3.disable_warnings()

class HermesException(Exception):
    """Generic exception used to indicate a problem with a Hermes operation"""
    pass

def retry(num_attempts, min_sleep=.1, max_sleep=5):
    for num in range(1, num_attempts+1):
        yield num

        # Don't sleep on final attempt. You've failed :(
        if num == num_attempts:
            break

        # Sleep longer for each attempt
        sleep_time = (min_sleep * (num * num))

        # Clamp the sleep time to max_sleep
        sleep_time = max(0, min(max_sleep, sleep_time))

        sleep(sleep_time)

def request_get(path):
    """Make an HTTP GET request for the given path

    Args:
        path: the full path to the resource
    Returns:
        the http response
    """
    for attempt in retry(settings.api_retries):
        response = requests.get(settings.hermes_server + path)
        if response.status_code < 500:
            break

    if response.status_code != requests.codes.ok or not response.content:
        try:
            data = response.json()["error"]["message"]
        except Exception:
            data = "Received invalid response: {}".format(response.content)

        raise HermesException(
            "Error: {}".format(data)
        )

    return response


def request_post(path, json):
    """Make an HTTP POST request for the given path

    If a non-OK status is returned, display the error message and exit

    Args:
        path: the full path to the resource
        json: the json to send in the body
    Returns:
        the http response
    """
    for attempt in retry(settings.api_retries):
        response = requests.post(settings.hermes_server + path, json=json)
        if response.status_code < 500:
            break

    if (
            response.status_code != requests.codes.created
            or not response.content
    ):
        try:
            data = response.json()["error"]["message"]
        except Exception:
            data = "Received invalid response: {}".format(response.content)
        raise HermesException(
            "Error: {}".format(data)
        )

    return response


def print_labor(labor, fates):
    """Print the details of a labor to standard out

    Args:
        labor: the labor to print
        fates: all the fates so we can give suggestions
    """
    creation_time = parser.parse(labor["creationTime"])
    creation_time = creation_time.replace(tzinfo=tz.tzutc())
    creation_time = creation_time.astimezone(tz.tzlocal())
    if labor.get("targetTime", None):
        target_time = parser.parse(labor["targetTime"])
        target_time = target_time.replace(tzinfo=tz.tzutc())
        target_time = target_time.astimezone(tz.tzlocal())
        target_time_str = "(due by {})".format(target_time)
    else:
        target_time_str = ""

    print "[{}] {}: \n\tcreated on {} {} \n\tby event {} {}  {}".format(
        labor["id"],
        labor["host"]["hostname"],
        creation_time,
        target_time_str,
        labor["creationEvent"]["eventType"]["category"],
        labor["creationEvent"]["eventType"]["state"],
        labor["creationEvent"]["note"] or ""
    )

    if labor.get("questId", None):
        print "\n\tPart of Quest [{}] created by {}".format(
            labor["quest"]["id"],
            labor["quest"]["creator"]
        )
        print "\t\"{}\"".format(textwrap.fill(
            labor["quest"]["description"],
            width=60, subsequent_indent="\t "
        ))

    print "\n\tPossible Resolutions:"
    for fate in fates:
        if fate["creationEventTypeId"] == labor["creationEvent"]["eventType"]["id"]:
            print "{}".format(textwrap.fill(
                fate["description"], width=60,
                initial_indent="\t* ", subsequent_indent="\t   "
            ))
    print ""


def list_event_types(args):
    logging.debug("list_event_types()")

    response = request_get("/api/v1/eventtypes?limit=all")

    event_types = response.json()

    max_length = 0
    for event_type in event_types["eventTypes"]:
        if len(str(event_type["id"])) > max_length:
            max_length = len(str(event_type["id"]))

    print"{}{}{}".format(
        str.ljust("ID", max_length + 3),
        str.ljust("CATEGORY", 20), str.ljust("STATE", 20)
    )
    for event_type in event_types["eventTypes"]:
        print "{}{}{}".format(
            str.ljust("[" + str(event_type["id"]) + "]", max_length + 3),
            str.ljust(str(event_type["category"]), 20),
            str.ljust(str(event_type["state"]), 20)
        )


def create_event_type(args):
    logging.debug("create_event_type({},{})", args.category, args.state)

    json = {
        "category": args.category,
        "state": args.state,
        "description": args.description
    }

    response = request_post("/api/v1/eventtypes", json)

    if response.json()["status"] == "created":
        print "Created event type {}".format(response.json()["id"])
    else:
        sys.exit(
            "Received unexpected status {}".format(response.json()["status"])
        )


def list_fates(args):
    logging.debug("list_fates()")

    response = request_get("/api/v1/fates?limit=all&expand=eventtypes")
    fates = response.json()["fates"]

    print "FATES  ([id] created by => completed by)"
    print "       * = intermediate\n"
    for fate in fates:
        print "[{}]{} {} => {}".format(
            fate["id"],
            "*" if fate["intermediate"] else " ",
            (
                fate["creationEventType"]["category"]
                + "-" + fate["creationEventType"]["state"]
            ),
            (
                fate["completionEventType"]["category"]
                + "-" + fate["completionEventType"]["state"]
            )
        )
        print fate["description"]
        print ""


def create_fate(args):
    logging.debug("create_fates()")
    if not args.ct and not (args.cc and args.cs):
        print (
            "To create a fate, you must specify either --creation-type,\nor "
            "--creation-category and creation-state."
        )
        return
    if not args.xt and not (args.xc and args.xs):
        print (
            "To create a fate, you must specify either --completion-type,\nor "
            "--completion-category and completion-state."
        )
        return

    response = request_get("/api/v1/eventtypes?limit=all")
    event_types = response.json()["eventTypes"]

    creation_event_type = None
    completion_event_type = None
    for event_type in event_types:

        if args.cc == event_type["category"] \
                and args.cs == event_type["state"]:
            creation_event_type = event_type
        elif args.ct == event_type["id"]:
            creation_event_type = event_type

        if args.xc == event_type["category"] \
                and args.xs == event_type["state"]:
            completion_event_type = event_type
        elif args.xt == event_type["id"]:
            completion_event_type = event_type

    if not creation_event_type:
        print "Creation event type not found."
        return

    if not completion_event_type:
        print "Completion event type not found."
        return

    json = {
        "creationEventTypeId": creation_event_type["id"],
        "completionEventTypeId": completion_event_type["id"],
        "intermediate": args.intermediate,
        "description": args.description
    }

    response = request_post("/api/v1/fates", json)

    if response.json()["status"] == "created":
        print "Created fate {}".format(response.json()["id"])
    else:
        sys.exit(
            "Received unexpected status {}".format(response.json()["status"])
        )


def list_hosts(args):
    logging.debug("list_hosts()")
    response = request_get("/api/v1/hosts?limit=all")
    hosts = response.json()["hosts"]
    print "HOSTS:"
    for host in hosts:
        print "{}".format(host["hostname"])


def add_host(args):
    logging.debug("add_host(%s)", args.hostname)
    response = request_get("/api/v1/hosts?hostname={}".format(args.hostname))
    hosts = response.json()

    if hosts["totalHosts"] > 0:
        sys.exit("Host {} already exists".format(args.hostname))

    json = {
        "hostname": args.hostname
    }

    response = request_post("/api/v1/hosts", json)

    if response.json()["status"] == "created":
        print "Created host {}".format(response.json()["hostname"])
    else:
        sys.exit(
            "Received unexpected status adding host {}".format(response.json()["status"])
        )


def list_host_last_state(args):
    logging.debug("list_host_last_state(%s)", args.hostname)

    response = request_get("/api/v1/eventtypes?limit=all")
    event_types = response.json()["eventTypes"]

    latest_by_category = []

    for event_type in event_types:
        response = request_get(
            "/api/v1/events/?limit=1&hostname={}&eventTypeId={}".format(
                args.hostname,
                event_type["id"]
            )
        )
        events = response.json()["events"]
        if events:
            event = events[0]
            # see if have an entry for this category, and if we do
            # see if this one is more recent
            updated = False
            for entry in latest_by_category:
                if (
                    entry["category"] == event_type["category"]
                    and entry["timestamp"] < event["timestamp"]
                ):
                    entry["state"] = event_type["state"]
                    entry["timestamp"] = event["timestamp"]
                    updated = True

            # if we didn't update an entry, we need to add one for this category
            if not updated:
                latest_by_category.append({
                    "category": event_type["category"],
                    "state": event_type["state"],
                    "timestamp": event["timestamp"]
                })

    for entry in latest_by_category:
        timestamp = parser.parse(entry["timestamp"])
        timestamp = timestamp.replace(tzinfo=tz.tzutc())
        timestamp = timestamp.astimezone(tz.tzlocal())
        print "{} {}: {}".format(
            entry["category"], entry["state"],
            timestamp
        )


def list_host_events(args):
    logging.debug("list_host_events(%s)", args.hostname)

    response = request_get(
        "/api/v1/hosts/{}?expand=events&expand=eventtypes&limit={}".format(
            args.hostname,
            args.limit
        )
    )

    host = response.json()
    events = host["events"]

    print "EVENTS FOR {} (up to {}):".format(host["hostname"], args.limit)
    for event in events:
        timestamp = parser.parse(event["timestamp"])
        timestamp = timestamp.replace(tzinfo=tz.tzutc())
        timestamp = timestamp.astimezone(tz.tzlocal())
        print "{}  {} {}  {}".format(
            timestamp, event["eventType"]["category"],
            event["eventType"]["state"], event["note"]
        )


def list_host_labors(args):
    logging.debug("list_host_labors(%s)", args.hostname)

    response = request_get(
            "/api/v1/labors/"
            "?open=true&expand=hosts&expand=eventtypes&expand=events"
            "&expand=quests&limit={}&hostname={}".format(
                args.limit,
                args.hostname
            )
        )

    labors = response.json()["labors"]

    response = request_get("/api/v1/fates?limit=all&expand=eventtypes")
    fates = response.json()["fates"]

    print "OPEN LABORS FOR {} (up to {}):".format(args.hostname, args.limit)
    for labor in labors:
        print_labor(labor, fates)


def list_host_labors_monitoring(args):
    """Check the host for open labors and report it like a plugin for Nagios

    Args:
        hostname: the host we want to check
    Returns:
        prints out the Nagios response and exits per plugin specs
    """
    logging.debug("list_host_labors_monitoring(%s)", args.hostname)

    try:
        response = request_get(
            "/api/v1/labors/"
            "?open=true&expand=hosts&expand=eventtypes&expand=events"
            "&expand=quests&limit=all&hostname={}".format(
                args.hostname
            )
        )
        json = response.json()
        labors = json["labors"]

    except HermesException as exc:
        # FIXME -- add error codes to Hermes API and test for that
        if exc.message.startswith("Error: No host"):
            # if the error was that the hostname wasn't found, just return
            # an empty list because hermes doesn't know about this host and
            # so we can assume it has no open labors
            labors = []
        else:
            print "UNKNOWN: Querying Hermes returned an exception"
            print ""
            traceback.print_exc(file=sys.stdout)
            sys.exit(3)
    except Exception as exc:
        print "UNKNOWN: Querying Hermes returned an exception"
        print ""
        traceback.print_exc(file=sys.stdout)
        sys.exit(3)

    response = request_get("/api/v1/fates?limit=all&expand=eventtypes")
    fates = response.json()["fates"]

    if labors:
        print "WARNING: {} open labor{} for this host".format(
            len(labors),
            "s" if len(labors) > 1 else ""
        )
        print ""
        for labor in labors:
            print_labor(labor, fates)
        print ""
        print "For more details, login to shelby and run:"
        print "hermes host labors {}".format(args.hostname)
        sys.exit(1)
    else:
        print "OK: No open labors for this host"
        sys.exit(0)

def list_labors(args):
    logging.debug("list_labors()")

    url = "/api/v1/labors/?limit={}&open=true&expand=events&expand=hosts&expand=eventtypes&expand=quests".format(args.limit)

    if args.query:
        url += "&hostQuery={}".format(args.query)
    if args.user:
        url += "&userQuery={}".format(args.user)

    response = request_get(url)
    labors = response.json()["labors"]
    total_labors = response.json()["totalLabors"]

    response = request_get("/api/v1/fates?limit=all&expand=eventtypes")
    fates = response.json()["fates"]

    print "OPEN LABORS ({} of {}):".format(len(labors), total_labors)
    for labor in labors:
        print_labor(labor, fates)


def create_event(args):
    logging.debug("create_event()")
    logging.debug(
        "host: %s    category: %s    state: %s    note: %s",
        args.hostname, args.category, args.state, args.note
    )

    response = request_get("/api/v1/eventtypes?limit=all")
    event_types = response.json()["eventTypes"]

    found_event_type = None
    for event_type in event_types:
        if (
            event_type["category"] == args.category
                and event_type["state"] == args.state
        ):
            found_event_type = event_type

    if found_event_type is None:
        sys.exit(
            "No matching event type found for {} {}".format(
                args.category, args.state
            )
        )

    user = getpass.getuser()

    json = {
        "hostname": args.hostname,
        "user": user,
        "eventTypeId": found_event_type["id"],
        "note": args.note
    }

    response = request_post("/api/v1/events", json)

    if response.json()["status"] == "created":
        print "Created event {}".format(response.json()["id"])
    else:
        sys.exit(
            "Received unexpected status {}".format(response.json()["status"])
        )


def list_quests(args):
    logging.debug("list_quests()")

    response = request_get(
        "/api/v1/quests?filterClosed=true&limit=all&expand=labors"
    )
    quests = response.json()["quests"]

    print "OPEN QUESTS:"
    for quest in quests:
        embark_time = parser.parse(quest["embarkTime"])
        embark_time = embark_time.replace(tzinfo=tz.tzutc())
        embark_time = embark_time.astimezone(tz.tzlocal())
        print "[{}] by {}.\n\tEmbarked on {}".format(
            quest["id"], quest["creator"],
            embark_time
        )
        print "\t\"{}\"".format(textwrap.fill(
            quest["description"],
            width=60, subsequent_indent="\t "
        ))
        if quest["targetTime"]:
            target_time = parser.parse(quest["targetTime"])
            target_time = target_time.replace(tzinfo=tz.tzutc())
            target_time = target_time.astimezone(tz.tzlocal())
            print"\tTarget Completion: {}".format(target_time)

        labors_remaining = 0
        for labor in quest["labors"]:
            if labor["completionTime"] is None:
                labors_remaining += 1

        total_labors = len(quest["labors"])
        print "\n\t{:.2%} complete.  {} total labors.  {} remain open.\n".format(
            (total_labors - labors_remaining)/total_labors,
            total_labors,
            labors_remaining
        )


def show_quest(args):
    logging.debug("show_quest(%d)", args.quest_id)
    url = (
        "/api/v1/quests/{}?filterClosed=true&limit=all"
        "&expand=labors&expand=hosts&expand=events&expand=eventtypes".format(
            args.quest_id
        )
    )
    response = request_get(url)
    quest = response.json()

    max_width = 0
    remaining = []
    completed = []
    for labor in quest["labors"]:
        if len(labor["host"]["hostname"]) > max_width:
            max_width = len(labor["host"]["hostname"])

        if labor["completionTime"] is None:
            remaining.append(labor)
        else:
            completed.append(labor)

    if not args.list_only:
        print "QUEST {}:".format(args.quest_id)
        embark_time = parser.parse(quest["embarkTime"])
        embark_time = embark_time.replace(tzinfo=tz.tzutc())
        embark_time = embark_time.astimezone(tz.tzlocal())
        print "{} by {}.\n\tEmbarked on {}".format(
            quest["description"], quest["creator"], embark_time
        )
        if quest["targetTime"]:
            target_time = parser.parse(quest["targetTime"])
            target_time = target_time.replace(tzinfo=tz.tzutc())
            target_time = target_time.astimezone(tz.tzlocal())
            print"\tTarget Completion: {}".format(target_time)

        if args.all or args.completed_only:
            for labor in completed:
                completion_time = parser.parse(labor["completionTime"])
                completion_time = completion_time.replace(tzinfo=tz.tzutc())
                completion_time = completion_time.astimezone(tz.tzlocal())
                print "{} achieved {} {} on {}".format(
                    labor["host"]["hostname"].rjust(max_width + 4),
                    labor["creationEvent"]["eventType"]["category"],
                    labor["creationEvent"]["eventType"]["state"],
                    completion_time
                )
        if not args.completed_only:
            for labor in remaining:
                print "{} must achieve {} {}".format(
                    labor["host"]["hostname"].rjust(max_width + 4),
                    labor["creationEvent"]["eventType"]["category"],
                    labor["creationEvent"]["eventType"]["state"]
                )

        total_labors = len(quest["labors"])
        labors_remaining = len(remaining)
        labors_completed = len(completed)
        print "{:.2%} complete.  {} total labors.  {} remain open.\n".format(
            labors_completed/total_labors,
            total_labors,
            labors_remaining
        )
    else:
        if args.completed_only or args.all:
            for labor in completed:
                print labor["host"]["hostname"]
        if not args.completed_only:
            for labor in remaining:
                print labor["host"]["hostname"]


def create_quest(args):
    logging.debug("create_quest()")
    logging.debug(
        "category: %s    state: %s    note: %s",
        args.category, args.state, args.description
    )

    print "Creating quest... (could take some time)"

    hosts = []
    if args.hosts:
        for hostname in args.hosts.split(","):
            if not hostname:
                continue
            hosts.append(hostname)
    elif not args.query:
        for hostname in sys.stdin.read().split("\n"):
            if not hostname:
                continue
            logging.debug("Entered host: %s", hostname)
            hosts.append(hostname)

    if not hosts and not args.query:
        logging.error("No hosts specified")
        return

    response = request_get("/api/v1/eventtypes?limit=all")
    event_types = response.json()["eventTypes"]

    found_event_type = None
    for event_type in event_types:
        if (
            event_type["category"] == args.category
                and event_type["state"] == args.state
        ):
            found_event_type = event_type

    if found_event_type is None:
        sys.exit(
            "No matching event type found for {} {}".format(
                args.category, args.state
            )
        )

    user = getpass.getuser()

    json = {
        "eventTypeId": found_event_type["id"],
        "creator": user,
        "description": args.description,
        "hostnames": hosts
    }

    if args.query:
        json["hostQuery"] = args.query

    if args.due:
        try:
            target_time = parser.parse(args.due, yearfirst=True)
            target_time = target_time.replace(tzinfo=tz.tzlocal())
            target_time = target_time.astimezone(tz.tzutc())
            target_time = target_time.replace(tzinfo=None)
            json["targetTime"] = str(target_time)
        except ValueError:
            sys.exit(
                "Invalid target date: {}"
                " -- must be in the form of YYYY-MM-DD HH:MM, "
                "with hours and minutes optional".format(args.due)
            )

    response = request_post("/api/v1/quests", json)
    if response.json()["status"] == "created":
        print "Created quest {} with {} labors".format(
            response.json()["id"],
            len(response.json()["labors"])
        )
    else:
        sys.exit(
            "Received unexpected status {}".format(response.json()["status"])
        )


def parse_cli_args():
    description_msg = "Hermes CLI"
    parser = argparse.ArgumentParser(description=description_msg)

    parser.add_argument("-c", "--config", default="/etc/hermes/client.yaml",
                        help="Path to config file.")
    parser.add_argument(
        "-s", "--server", dest="hermes_server"
    )
    parser.add_argument(
        "-v", "--verbose", action="count", default=0,
        help="Increase logging verbosity."
    )
    parser.add_argument(
        "-q", "--quiet", action="count", default=0,
        help="Decrease logging verbosity."
    )
    parser.add_argument("-V", "--version", action="version",
                        version="%%(prog)s %s" % hermes.__version__,
                        help="Display version information.")

    subparsers = parser.add_subparsers()

    # event type command line parser
    event_type_parser = subparsers.add_parser(
        "event-type", help="Create and list event types"
    )
    event_type_subparser = event_type_parser.add_subparsers()
    # event type list command line parser
    event_type_list_parser = event_type_subparser.add_parser("list")
    event_type_list_parser.set_defaults(func=list_event_types)
    # event type create command line parser
    event_type_create_parser = event_type_subparser.add_parser("create")
    event_type_create_parser.add_argument(
        "category",
        help="Category of the new event type"
    )
    event_type_create_parser.add_argument(
        "state",
        help="State of the new event type"
    )
    event_type_create_parser.add_argument(
        "-d", "--description", required=True,
        help="Human readable description for this event type"
    )
    event_type_create_parser.set_defaults(func=create_event_type)

    # fate command line parser
    fate_parser = subparsers.add_parser(
        "fate", help="Create and list fates"
    )
    # fate list parser
    fate_subparser = fate_parser.add_subparsers()
    fate_list_subparser = fate_subparser.add_parser("list")
    fate_list_subparser.set_defaults(func=list_fates)
    # fate create parser
    fate_create_subparser = fate_subparser.add_parser("create")
    fate_create_subparser.add_argument(
        "-cc", "--creation-category", help="The category of the creation event type",
        dest="cc", type=str
    )
    fate_create_subparser.add_argument(
        "-cs", "--creation-state", help="The state of the creation event type",
        dest="cs", type=str
    )
    fate_create_subparser.add_argument(
        "-ct", "--creation-type", help="The ID of the creation type",
        dest="ct", type=str
    )
    fate_create_subparser.add_argument(
        "-xc", "--completion-category",
        help="The category of the completion event type",
        dest="xc", type=str
    )
    fate_create_subparser.add_argument(
        "-xs", "--completion-state", help="The state of the completion event type",
        dest="xs", type=str
    )
    fate_create_subparser.add_argument(
        "-xt", "--completion-type", help="The ID of the completion event type",
        dest="xt", type=str
    )
    fate_create_subparser.add_argument(
        "-i", "--intermediate", action="store_true",
        help="When flagged, this fate only creates a new labor if closing an existing one"
    )
    fate_create_subparser.add_argument(
        "--description", help="The human readable description of this fate",
        required=True
    )
    fate_create_subparser.set_defaults(func=create_fate)

    # Add host command line parser
    host_parser = subparsers.add_parser("host", help="Host level operations")
    host_subparser = host_parser.add_subparsers()
    # Host list parser
    host_list_parsers = host_subparser.add_parser("list")
    host_list_parsers.set_defaults(func=list_hosts)
    # Host add parser
    host_add_parser = host_subparser.add_parser("add")
    host_add_parser.add_argument("hostname")
    host_add_parser.set_defaults(func=add_host)
    # Host events parsers
    host_events_parser = host_subparser.add_parser("events")
    host_events_parser.add_argument("hostname")
    host_events_parser.add_argument(
        "-l", "--limit", default=20, type=int,
        help="Limit the number of events displayed"
    )
    host_events_parser.set_defaults(func=list_host_events)
    # Host last unique events
    host_events_parser = host_subparser.add_parser("last-state")
    host_events_parser.add_argument("hostname")
    host_events_parser.set_defaults(func=list_host_last_state)
    # Host labors parser
    host_labors_parser = host_subparser.add_parser("labors")
    host_labors_parser.add_argument("hostname")
    host_labors_parser.add_argument(
        "-l", "--limit", default=20, type=int,
        help="Limit the number of labors displayed"
    )
    host_labors_parser.set_defaults(func=list_host_labors)
    # Host monitoring plugin output
    host_monitoring_parser = host_subparser.add_parser("monitoring")
    host_monitoring_parser.add_argument("hostname")
    host_monitoring_parser.set_defaults(func=list_host_labors_monitoring)

    # labors command line parser
    labor_parser = subparsers.add_parser(
        "labor", help="List labors"
    )
    labor_subparser = labor_parser.add_subparsers()
    labor_list_parser = labor_subparser.add_parser("list")
    labor_list_parser.add_argument(
        "-l", "--limit", default=20, type=int,
        help="Limit the number of labors displayed"
    )
    labor_list_parser.add_argument(
        "--query", type=str,
        help="Query for hosts with a search string"
    )
    labor_list_parser.add_argument(
        "--user", type=str,
        help="Query for hosts by user responsible"
    )
    labor_list_parser.set_defaults(func=list_labors)

    # events command line parser
    event_parser = subparsers.add_parser(
        "event", help="Create and list events"
    )
    event_subparser = event_parser.add_subparsers()
    event_create_parser = event_subparser.add_parser("create")
    event_create_parser.add_argument("hostname")
    event_create_parser.add_argument("category")
    event_create_parser.add_argument("state")
    event_create_parser.add_argument(
        "-n", "--note", type=str, help="Note to attach to the Event"
    )
    event_create_parser.set_defaults(func=create_event)

    # quest command line parser
    quest_parser = subparsers.add_parser(
        "quest", help="Create and list Quests"
    )
    quest_subparser = quest_parser.add_subparsers()
    # quest list parser
    quest_list_parser = quest_subparser.add_parser("list")
    quest_list_parser.set_defaults(func=list_quests)
    # quest show parser
    quest_show_parser = quest_subparser.add_parser("show")
    quest_show_parser.add_argument("quest_id")
    quest_show_list_options = quest_show_parser.add_mutually_exclusive_group()
    quest_show_list_options.add_argument(
        "--all", action="store_true",
        help="Show all associated labors"
    )
    quest_show_list_options.add_argument(
        "--completed", action="store_true", dest="completed_only",
        help="Show only completed labors"
    )
    quest_show_parser.add_argument(
        "--list", dest="list_only", action="store_true",
        help="Only output a list of hostnames with open labors"
    )
    quest_show_parser.set_defaults(func=show_quest)
    # quest creation parser
    quest_create_parser = quest_subparser.add_parser("create")
    quest_create_parser.add_argument("category")
    quest_create_parser.add_argument("state")
    quest_create_parser.add_argument(
        "--due", type=str,
        help="Target date as YYYY-MM-DD HH:MM, with hours and minutes optional"
    )
    quest_create_parser.add_argument(
        "-d", "--description", type=str, required=True,
        help="Description to attach to the Quest"
    )
    quest_create_parser.add_argument(
        "--hosts", type=str,
        help="Comma separated Hosts involved in this Quest"
    )
    quest_create_parser.add_argument(
        "--query", type=str,
        help="Query for hosts with a search string"
    )
    quest_create_parser.set_defaults(func=create_quest)

    return parser.parse_args()


def main():
    args = parse_cli_args()
    settings.update_from_config(args.config)

    if args.hermes_server:
        settings.hermes_server = args.hermes_server

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG, format=settings.log_format)
    elif args.quiet:
        logging.basicConfig(level=logging.ERROR, format=settings.log_format)
    else:
        logging.basicConfig(level=logging.INFO, format=settings.log_format)

    args.func(args)


if __name__ == "__main__":
    main()
