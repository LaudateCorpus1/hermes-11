#!/usr/bin/env python

""" Command-line interface to Hermes."""

from __future__ import division

import argparse
from dateutil import parser, tz
from datetime import datetime
import getpass
import logging
import requests
from requests.packages import urllib3
import sys
import textwrap
from time import sleep
import traceback
import urllib


import hermes
from hermes.settings_client import settings

logging.getLogger("requests").setLevel(logging.WARNING)
urllib3.disable_warnings()


class HermesException(Exception):
    """Generic exception used to indicate a problem with a Hermes operation"""
    pass


class HermesNotFound(Exception):
    """Thrown when something is not found"""
    pass


def retry(num_attempts, min_sleep=.1, max_sleep=5):
    for num in range(1, num_attempts+1):
        yield num

        # Don't sleep on final attempt. You've failed :(
        if num == num_attempts:
            break

        # Sleep longer for each attempt
        sleep_time = (min_sleep * (num * num))

        # Clamp the sleep time to max_sleep
        sleep_time = max(0, min(max_sleep, sleep_time))

        sleep(sleep_time)


def request_get(path):
    """Make an HTTP GET request for the given path

    Args:
        path: the full path to the resource
    Returns:
        the http response
    """
    for attempt in retry(settings.api_retries):
        response = requests.get(settings.hermes_server + path)
        if response.status_code < 500:
            break

    if 400 <= response.status_code < 500:
        raise HermesNotFound("{} returned {}".format(
            settings.hermes_server + path, response.status_code)
        )

    if response.status_code != requests.codes.ok or not response.content:
        try:
            data = response.json()["error"]["message"]
        except Exception:
            data = "Received invalid response: {}".format(response.content)

        raise HermesException(
            "Error: {} {} {}".format(response.status_code, requests.codes.ok, data)
        )

    return response


def request_post(path, json):
    """Make an HTTP POST request for the given path

    If a non-OK status is returned, display the error message and exit

    Args:
        path: the full path to the resource
        json: the json to send in the body
    Returns:
        the http response
    """
    for attempt in retry(settings.api_retries):
        response = requests.post(settings.hermes_server + path, json=json)
        if response.status_code < 500:
            break

    if response.status_code == requests.codes.not_found:
        raise HermesNotFound("{} returned 404".format(
            settings.hermes_server + path)
        )

    if (
            response.status_code not in (
                requests.codes.created, requests.codes.ok
            )
            or not response.content
    ):
        try:
            data = response.json()["error"]["message"]
        except Exception:
            data = "Received invalid response: {} {}".format(
                response.status_code, response.content
            )
        raise HermesException(
            "Error: {}".format(data)
        )

    return response


def request_put(path, json):
    """Make an HTTP PUT request for the given path

    If a non-OK status is returned, display the error message and exit

    Args:
        path: the full path to the resource
        json: the json to send in the body
    Returns:
        the http response
    """
    for attempt in retry(settings.api_retries):
        response = requests.put(settings.hermes_server + path, json=json)
        if response.status_code < 500:
            break

    if response.status_code == requests.codes.not_found:
        raise HermesNotFound("{} returned 404".format(
            settings.hermes_server + path)
        )

    if (
            response.status_code != requests.codes.ok
            or not response.content
    ):
        try:
            data = response.json()["error"]["message"]
        except Exception:
            data = "Received invalid response: {}".format(response.content)
        raise HermesException(
            "Error: {}".format(data)
        )

    return response


def ping_server(args):
    """Ping the Hermes API server and ensure it responds.  Return output
    appropriate for a Nagios-style monitoring service.
    """
    try:
        response = request_get("/api/v1/eventtypes?limit=1")
    except Exception as exc:
        print "CRIT: Error in Hermes API server response"
        print ""
        traceback.print_exc(file=sys.stdout)
        sys.exit(2)

    print "OK: Hermes server seems ok"
    print ""
    print "Successfully ran a simple query against the Hermes API"
    sys.exit(0)


def print_labor(labor, fates, verbose=False, tags=None):
    """Print the details of a labor to standard out

    Args:
        labor: the labor to print
        fates: all the fates so we can give suggestions
    """
    creation_time = parser.parse(labor["creationTime"])
    creation_time = creation_time.replace(tzinfo=tz.tzutc())
    creation_time = creation_time.astimezone(tz.tzlocal())

    print "({}) {}:".format(
        labor["id"],
        labor["host"]["hostname"]
    )

    if tags:
        print "\tTags: {}\n".format(textwrap.fill(
            ", ".join(tags), width=50, subsequent_indent="\t      "
        ))

    if verbose:
        print "\tCreated: {}".format(creation_time)

    if labor.get("targetTime", None):
        target_time = parser.parse(labor["targetTime"])
        target_time = target_time.replace(tzinfo=tz.tzutc())
        target_time = target_time.astimezone(tz.tzlocal())
        print "\tDue by {}".format(target_time)

    if verbose:
        print "\tCreated by: {} {}".format(
            labor["creationEvent"]["eventType"]["category"],
            labor["creationEvent"]["eventType"]["state"]
        )

    if labor["creationEvent"]["note"] and verbose:
        print "\tNote: \"{}\"".format(labor["creationEvent"]["note"])

    if labor.get("questId", None):
        print "\n\tPart of Quest [{}] created by {}".format(
            labor["quest"]["id"],
            labor["quest"]["creator"]
        )
        print "\t\"{}\"".format(textwrap.fill(
            labor["quest"]["description"],
            width=60, subsequent_indent="\t "
        ))

    print "\n\tPossible Resolutions:"
    for fate in fates:
        if (
            fate["id"]
                == labor["fateId"]
        ):
            print "{}".format(textwrap.fill(
                fate["description"], width=60,
                initial_indent="\t* ", subsequent_indent="\t   "
            ))
    print ""


def list_event_types(args):
    logging.debug("list_event_types()")

    response = request_get("/api/v1/eventtypes?limit=all")

    event_types = response.json()

    max_length = 0
    for event_type in event_types["eventTypes"]:
        if len(str(event_type["id"])) > max_length:
            max_length = len(str(event_type["id"]))

    print "{}{}{}{}".format(
        str.ljust("ID", max_length + 4),
        str.ljust("CATEGORY", 20),
        str.ljust("STATE", 20),
        str.ljust("DESC", 20)
    )
    for event_type in event_types["eventTypes"]:
        type_id = (
            str(event_type["id"]) + "*"
            if event_type["restricted"] else str(event_type["id"])
        )
        print "{}{}{}{}".format(
            str.ljust("(" + type_id + ")", max_length + 4),
            str.ljust(str(event_type["category"]), 20),
            str.ljust(str(event_type["state"]), 20),
            str.ljust(str(event_type["description"]), 20)
        )

    print "\n* = restricted; cannot be thrown by hand."


def create_event_type(args):
    logging.debug(
        "create_event_type(%s,%s)  Restricted? %s",
        args.category, args.state, args.restricted
    )

    json = {
        "category": args.category,
        "state": args.state,
        "description": args.description,
        "restricted": args.restricted
    }

    response = request_post("/api/v1/eventtypes", json)

    if response.json()["status"] == "created":
        print "Created event type {}".format(response.json()["id"])
    else:
        sys.exit(
            "Received unexpected status {}".format(response.json()["status"])
        )


def list_fates(args):
    logging.debug("list_fates()")

    response = request_get("/api/v1/fates?limit=all&expand=eventtypes")
    fates = response.json()["fates"]

    print "FATES:  \n(id) created by => completed by\n"
    for fate in fates:
        if not fate.get("precedesIds"):
            print "  ({}) {}".format(
                fate["id"],
                fate["creationEventType"]["category"] + " "
                + fate["creationEventType"]["state"]
            )
        else:
            print "{} ({}) {} => {}".format(
                "*" if not fate["followsId"] else " ",
                fate["id"],
                fate["creationEventType"]["category"] + " "
                + fate["creationEventType"]["state"],
                fate["precedesIds"]
            )

        print textwrap.fill(
            fate["description"], width=60,
            initial_indent="\t", subsequent_indent="\t"
        )
        print ""

    print "FATES that can start labors/quests:"
    for fate in fates:
        if not fate["followsId"]:
            print "* ({}) {} => {}".format(
                fate["id"],
                fate["creationEventType"]["category"] + " "
                + fate["creationEventType"]["state"],
                fate["precedesIds"]
            )

            print textwrap.fill(
                fate["description"], width=60,
                initial_indent="\t", subsequent_indent="\t"
            )

            print ""

    print "For a graphical view, visit:"
    print "\t{}/v1/fates".format(settings.hermes_server)


def create_fate(args):
    logging.debug("create_fates()")
    if not args.ct and not (args.cc and args.cs):
        print (
            "To create a fate, you must specify either --creation-type,\nor "
            "--creation-category and creation-state."
        )
        return

    if not args.for_owner and not args.for_creator:
        print (
            "To create a fate, you must specify either --for_owner or \n"
            "--for_creator (or both) to indicate whether labors created\n"
            "would be designated for action by server owners or Quest \n"
            "creators, respectively."
        )
        return

    response = request_get("/api/v1/eventtypes?limit=all")
    event_types = response.json()["eventTypes"]

    creation_event_type = None

    for event_type in event_types:
        if args.cc == event_type["category"] \
                and args.cs == event_type["state"]:
            creation_event_type = event_type
        elif args.ct == str(event_type["id"]):
            creation_event_type = event_type

    if not creation_event_type:
        print "Creation event type not found."
        return

    json = {
        "creationEventTypeId": creation_event_type["id"],
        "followsId": args.follows_id,
        "description": args.description,
        "forCreator": args.for_creator,
        "forOwner": args.for_owner
    }

    response = request_post("/api/v1/fates", json)

    if response.json()["status"] == "created":
        print "Created fate {}".format(response.json()["id"])
    else:
        sys.exit(
            "Received unexpected status {}".format(response.json()["status"])
        )


def list_hosts(args):
    logging.debug("list_hosts()")
    response = request_get("/api/v1/hosts?limit=all")
    hosts = response.json()["hosts"]
    print "HOSTS:"
    for host in hosts:
        print "{}".format(host["hostname"])


def add_host(args):
    logging.debug("add_host(%s)", args.hostname)
    response = request_get("/api/v1/hosts?hostname={}".format(args.hostname))
    hosts = response.json()

    if hosts["totalHosts"] > 0:
        sys.exit("Host {} already exists".format(args.hostname))

    json = {
        "hostname": args.hostname
    }

    response = request_post("/api/v1/hosts", json)

    if response.json()["status"] == "created":
        print "Created host {}".format(response.json()["hostname"])
    else:
        sys.exit(
            "Received unexpected status adding host {}".format(response.json()["status"])
        )


def rename_host(args):
    logging.debug("rename_host(%s, %s)", args.oldname, args.newname)
    response = request_get("/api/v1/hosts?hostname={}".format(args.oldname))
    hosts = response.json()

    if hosts["totalHosts"] != 1:
        sys.exit("Host {} does not exist".format(args.oldname))

    json = {
        "hostname": args.newname
    }

    response = request_put("/api/v1/hosts/{}".format(args.oldname), json)

    if response.json()["status"] == "ok":
        print "Renamed host {} to {}".format(
            args.oldname, response.json()["hostname"]
        )
    else:
        sys.exit(
            "Received unexpected status renaming host {}".format(args.oldname)
        )


def list_host_last_state(args):
    logging.debug("list_host_last_state(%s)", args.hostname)

    response = request_get("/api/v1/eventtypes?limit=all")
    event_types = response.json()["eventTypes"]

    latest_by_category = []

    for event_type in event_types:
        response = request_get(
            "/api/v1/events/?limit=1&hostname={}&eventTypeId={}".format(
                args.hostname,
                event_type["id"]
            )
        )
        events = response.json()["events"]
        if events:
            event = events[0]
            # see if have an entry for this category, and if we do
            # see if this one is more recent
            updated = False
            for entry in latest_by_category:
                if (
                    entry["category"] == event_type["category"]
                    and entry["timestamp"] < event["timestamp"]
                ):
                    entry["state"] = event_type["state"]
                    entry["timestamp"] = event["timestamp"]
                    updated = True

            # if we didn't update an entry, we need to add one for this category
            if not updated:
                latest_by_category.append({
                    "category": event_type["category"],
                    "state": event_type["state"],
                    "timestamp": event["timestamp"]
                })

    for entry in latest_by_category:
        timestamp = parser.parse(entry["timestamp"])
        timestamp = timestamp.replace(tzinfo=tz.tzutc())
        timestamp = timestamp.astimezone(tz.tzlocal())
        print "{} {}: {}".format(
            entry["category"], entry["state"],
            timestamp
        )


def list_host_events(args):
    logging.debug("list_host_events(%s)", args.hostname)

    response = request_get(
        "/api/v1/hosts/{}?expand=events&expand=eventtypes&limit={}".format(
            args.hostname,
            args.limit
        )
    )

    host = response.json()
    events = host["events"]

    print "EVENTS FOR {} (up to {}):".format(host["hostname"], args.limit)
    for event in events:
        timestamp = parser.parse(event["timestamp"])
        timestamp = timestamp.replace(tzinfo=tz.tzutc())
        timestamp = timestamp.astimezone(tz.tzlocal())
        print "{}  {} {}  {}".format(
            timestamp, event["eventType"]["category"],
            event["eventType"]["state"], event["note"]
        )


def list_host_labors(args):
    logging.debug(
        "list_host_labors(%s, %s, %s)", args.hostname, args.verbose, args.tags
    )

    response = request_get(
        "/api/v1/labors/"
        "?open=true&expand=hosts&expand=eventtypes&expand=events"
        "&expand=quests&limit={}&hostname={}".format(
            args.limit,
            args.hostname
        )
    )

    labors = response.json()["labors"]
    total_labors = response.json()["totalLabors"]

    response = request_get("/api/v1/fates?limit=all&expand=eventtypes")
    fates = response.json()["fates"]

    tags = None
    if args.tags:
        json = {
            "hostnames": [args.hostname],
            "operation": "tags"
        }

        response = request_post("/api/v1/extquery", json)
        tags = response.json()["results"][args.hostname]

    print "OPEN LABORS FOR {} ({} of {}):".format(
        args.hostname, len(labors), total_labors
    )
    for labor in labors:
        print_labor(labor, fates, args.verbose, tags)


def list_host_labors_monitoring(args):
    """Check the host for open labors and report it like a plugin for Nagios

    Args:
        hostname: the host we want to check
    Returns:
        prints out the Nagios response and exits per plugin specs
    """
    logging.debug("list_host_labors_monitoring(%s)", args.hostname)

    alert = False
    critical = False

    try:
        response = request_get(
            "/api/v1/labors/"
            "?open=true&expand=hosts&expand=eventtypes&expand=events"
            "&expand=quests&limit=all&hostname={}".format(
                args.hostname
            )
        )
        json = response.json()
        labors = json["labors"]

        # FIXME: we need a better way to detect alertable labors
        for labor in labors:
            if labor['creationEvent']['eventType']['state'] == "required":
                alert = True
            # determine if critical
            if labor['quest']['targetTime']:
                target_time = parser.parse(labor['quest']['targetTime'], yearfirst=True)
                target_time = target_time.replace(tzinfo=tz.tzlocal())
                target_time = target_time.astimezone(tz.tzutc())
                target_time = target_time.replace(tzinfo=None)
                time_left = target_time - datetime.now()
                if time_left.days <= 5:
                    critical = True

    except HermesNotFound:
        # if the error was that the hostname wasn't found, just return
        # an empty list because hermes doesn't know about this host and
        # so we can assume it has no open labors
        labors = []

    except HermesException as exc:
        # FIXME -- add error codes to Hermes API and test for that
        print "UNKNOWN: Hermes returned an exception"
        print ""
        traceback.print_exc(file=sys.stdout)
        sys.exit(3)

    response = request_get("/api/v1/fates?limit=all&expand=eventtypes")
    fates = response.json()["fates"]

    if alert:
        print "{}: {} open labor{} for this host".format(
            "CRIT" if critical else "WARNING",
            len(labors),
            "s" if len(labors) > 1 else ""
        )
        print ""
        for labor in labors:
            print_labor(labor, fates)
        print ""
        print "For more details, login to shelby and run:"
        print "hermes host labors {}".format(args.hostname)
        if critical:
            sys.exit(2)
        else:
            sys.exit(1)
    else:
        print "OK: No open labors for this host"
        sys.exit(0)


def list_labors(args):
    logging.debug("list_labors()")

    url = "/api/v1/labors/?limit={}&open=true&expand=events&expand=hosts&expand=eventtypes&expand=quests".format(args.limit)

    if args.query:
        url += "&hostQuery={}".format(urllib.quote_plus(args.query))
    if args.user:
        url += "&userQuery={}".format(urllib.quote_plus(args.user))

    response = request_get(url)
    labors = response.json()["labors"]
    total_labors = response.json()["totalLabors"]

    response = request_get("/api/v1/fates?limit=all&expand=eventtypes")
    fates = response.json()["fates"]

    tags = None
    if args.tags:
        hostnames = []
        for labor in labors:
            hostnames.append(labor["host"]["hostname"])
        json = {
            "hostnames": hostnames,
            "operation": "tags"
        }

        response = request_post("/api/v1/extquery", json)
        tags = response.json()["results"]

    print "OPEN LABORS ({} of {}):".format(len(labors), total_labors)
    for labor in labors:
        print_labor(
            labor, fates, args.verbose,
            tags[labor["host"]["hostname"]] if tags else None
        )


def create_event(args):
    logging.debug("create_event()")
    logging.debug(
        "host: %s  category: %s  state: %s  note: %s query: %s, quest: %s",
        args.hostname, args.category, args.state, args.note, args.query,
        args.quest_id
    )

    response = request_get("/api/v1/eventtypes?limit=all")
    event_types = response.json()["eventTypes"]

    found_event_type = None
    for event_type in event_types:
        if (
            event_type["category"] == args.category
                and event_type["state"] == args.state
                and event_type["restricted"] is False
        ):
            found_event_type = event_type
        if (
            event_type["category"] == args.category
                and event_type["state"] == args.state
                and event_type["restricted"] is True
        ):
            sys.exit(
                "{} {} is a restricted event type "
                "and cannot be thrown manually.".format(
                    args.category, args.state
                )
            )

    if found_event_type is None:
        sys.exit(
            "No matching event type found for {} {}".format(
                args.category, args.state
            )
        )

    user = getpass.getuser()

    json = {
        "user": user,
        "eventTypeId": found_event_type["id"],
        "note": args.note
    }

    if args.hostname:
        json["hostname"] = args.hostname

    if args.query:
        json["hostQuery"] = args.query

    if args.quest_id:
        json["questId"] = args.quest_id

    response = request_post("/api/v1/events", json)

    if response.json()["status"] == "created":
        if "totalEvents" in response.json():
            print "Created {} events".format(response.json()["totalEvents"])
        else:
            print "Created event {}".format(response.json()["id"])
    else:
        sys.exit(
            "Received unexpected status {}".format(response.json()["status"])
        )


def list_quests(args):
    logging.debug("list_quests()")

    url = "/api/v1/quests?filterClosed=true&limit=all&progressInfo=true"

    if args.user:
        url += "&byCreator={}".format(args.user)
    if args.hosts:
        url += "&hostnames={}".format(urllib.quote_plus(args.hosts))
    if args.query:
        url += "&hostQuery={}".format(urllib.quote_plus(args.query))

    response = request_get(url)
    quests = response.json()["quests"]

    print "OPEN QUESTS:"
    print "\t* Labors: unstarted/in-progress/completed/total\n\n"
    for quest in quests:
        embark_time = parser.parse(quest["embarkTime"])
        embark_time = embark_time.replace(tzinfo=tz.tzutc())
        embark_time = embark_time.astimezone(tz.tzlocal())
        print "({}) by {}.\n\tEmbarked on {}".format(
            quest["id"], quest["creator"],
            embark_time
        )
        print "\t\"{}\"".format(textwrap.fill(
            quest["description"],
            width=60, subsequent_indent="\t "
        ))
        if quest["targetTime"]:
            target_time = parser.parse(quest["targetTime"])
            target_time = target_time.replace(tzinfo=tz.tzutc())
            target_time = target_time.astimezone(tz.tzlocal())
            print"\tTarget Completion: {}".format(target_time)

        print "\n\t{}% complete. Labors: {}/{}/{}/{}\n".format(
            quest["percentComplete"], quest["unstartedLabors"],
            quest["inprogressLabors"], quest["completedLabors"],
            quest["totalLabors"]
        )


def show_quest(args):
    logging.debug("show_quest(%d)", args.quest_id)
    url = (
        "/api/v1/quests/{}?filterClosed=true&limit=all&progressInfo=true"
        "&expand=labors&expand=hosts&expand=events&expand=eventtypes".format(
            args.quest_id
        )
    )
    response = request_get(url)
    quest = response.json()

    max_width = 0
    remaining = []
    remaining_types = {}
    completed = []
    total_labors = 0
    total_unstarted = 0
    for labor in quest["labors"]:
        if labor["startingLaborId"] is None:
            total_labors += 1
            if labor["completionTime"] is None:
                total_unstarted += 1

        if len(labor["host"]["hostname"]) > max_width:
            max_width = len(labor["host"]["hostname"])

        if labor["completionTime"] is None:
            remaining.append(labor)
            type_key = "{} {}".format(
                labor["creationEvent"]["eventType"]["category"],
                labor["creationEvent"]["eventType"]["state"],
            )
            if type_key in remaining_types:
                remaining_types[type_key] += 1
            else:
                remaining_types[type_key] = 1
        else:
            completed.append(labor)

    if not args.list_only:
        embark_time = parser.parse(quest["embarkTime"])
        embark_time = embark_time.replace(tzinfo=tz.tzutc())
        embark_time = embark_time.astimezone(tz.tzlocal())
        print "\nQUEST {}: Embarked on {} by {}".format(
            args.quest_id,
            embark_time,
            quest["creator"],
        )
        if quest["targetTime"]:
            target_time = parser.parse(quest["targetTime"])
            target_time = target_time.replace(tzinfo=tz.tzutc())
            target_time = target_time.astimezone(tz.tzlocal())
            print"\tTarget Completion: {}".format(target_time)

        print "\n\"{}\"\n".format(
            textwrap.fill(
                quest["description"],
                width=76, subsequent_indent=" "
            )
        )

        print "\tLABORS:"
        if args.all or args.completed_only:
            for labor in completed:
                completion_time = parser.parse(labor["completionTime"])
                completion_time = completion_time.replace(tzinfo=tz.tzutc())
                completion_time = completion_time.astimezone(tz.tzlocal())
                print "\t{} achieved {} {} on {}".format(
                    labor["host"]["hostname"].rjust(max_width),
                    labor["creationEvent"]["eventType"]["category"],
                    labor["creationEvent"]["eventType"]["state"],
                    completion_time
                )
        if not args.completed_only:
            for labor in remaining:
                print "\t{} is currently {} {}".format(
                    labor["host"]["hostname"].rjust(max_width),
                    labor["creationEvent"]["eventType"]["category"],
                    labor["creationEvent"]["eventType"]["state"]
                )

        if remaining:
            print "\n\tOPEN LABORS BY TYPE:"
            for type in remaining_types.iterkeys():
                print "\t\t{}: {}".format(
                    type,
                    remaining_types[type]
                )
        print "\n\t{}% complete. {} not started, {} in progress, \n\t" \
              "{} completed, and {} total labors\n".format(
            quest["percentComplete"],
            quest["unstartedLabors"],
            quest["inprogressLabors"],
            quest["completedLabors"],
            quest["totalLabors"]
        )
    else:
        if args.completed_only or args.all:
            for labor in completed:
                print labor["host"]["hostname"]
        if not args.completed_only:
            for labor in remaining:
                print labor["host"]["hostname"]


def create_quest(args):
    logging.debug("create_quest()")
    logging.debug(
        "fate: %s    note: %s",
        args.fate_id, args.description
    )

    print "Creating quest... (could take some time)"

    hosts = []
    if args.hosts:
        for hostname in args.hosts.split(","):
            if not hostname:
                continue
            hosts.append(hostname)
    elif not args.query:
        for hostname in sys.stdin.read().split("\n"):
            if not hostname:
                continue
            logging.debug("Entered host: %s", hostname)
            hosts.append(hostname)

    if not hosts and not args.query:
        logging.error("No hosts specified")
        return

    try:
        response = request_get("/api/v1/fates/{}".format(args.fate_id))
        fate_json = response.json()

    except HermesNotFound:
        sys.exit(
            "ERROR: No matching fate found for id {}".format(
                args.fate_id
            )
        )

    if fate_json["followsId"] is not None:
        sys.exit(
            "ERROR: Fate {} is not a valid starting fate".format(args.fate_id)
        )

    user = getpass.getuser()

    json = {
        "fateId": args.fate_id,
        "creator": user,
        "description": args.description
    }

    if hosts:
        json["hostnames"] = hosts

    if args.query:
        json["hostQuery"] = args.query

    if args.due:
        try:
            target_time = parser.parse(args.due, yearfirst=True)
            target_time = target_time.replace(tzinfo=tz.tzlocal())
            target_time = target_time.astimezone(tz.tzutc())
            target_time = target_time.replace(tzinfo=None)
            json["targetTime"] = str(target_time)
        except ValueError:
            sys.exit(
                "Invalid target date: {}"
                " -- must be in the form of YYYY-MM-DD HH:MM, "
                "with hours and minutes optional".format(args.due)
            )

    response = request_post("/api/v1/quests", json)
    if response.json()["status"] == "created":
        print "Created quest {} with {} labors".format(
            response.json()["id"],
            len(response.json()["labors"])
        )
    else:
        sys.exit(
            "Received unexpected status {}".format(response.json()["status"])
        )


def edit_quest(args):
    logging.debug("edit_quest()")

    if not args.creator and not args.desc and not args.due:
        sys.exit(
            "Must specify a new creator, a new description, or a new due date."
        )

    try:
        response = request_get("/api/v1/quests/{}".format(args.quest_id))
    except HermesNotFound:
        sys.exit("Quest {} does not exist".format(args.quest_id))

    quest = response.json()

    json = {}

    if args.creator:
        json['creator'] = args.creator
    if args.desc:
        json['description'] = args.desc
    if args.due:
        try:
            target_time = parser.parse(args.due, yearfirst=True)
            target_time = target_time.replace(tzinfo=tz.tzlocal())
            target_time = target_time.astimezone(tz.tzutc())
            target_time = target_time.replace(tzinfo=None)
            json["targetTime"] = str(target_time)
        except ValueError:
            sys.exit(
                "Invalid target date: {}"
                " -- must be in the form of YYYY-MM-DD HH:MM, "
                "with hours and minutes optional".format(args.due)
            )

    response = request_put("/api/v1/quests/{}".format(args.quest_id), json)

    if response.json()["status"] == "ok":
        print "Quest {} updated: {} {} {}".format(
            args.quest_id,
            "creator set to {}".format(args.creator) if args.creator else "",
            "due date set to {}".format(args.due) if args.due else "",
            "desc set to {}".format(args.desc) if args.desc else ""
        )
    else:
        sys.exit(
            "Received unexpected status editing quest {}".format(args.quest_id)
        )


def parse_cli_args():
    description_msg = "Hermes CLI"
    parser = argparse.ArgumentParser(description=description_msg)

    parser.add_argument("-c", "--config", default="/etc/hermes/client.yaml",
                        help="Path to config file.")
    parser.add_argument(
        "-s", "--server", dest="hermes_server"
    )
    parser.add_argument(
        "--debug", action="count", default=0,
        help="Increase logging verbosity."
    )
    parser.add_argument(
        "-q", "--quiet", action="count", default=0,
        help="Decrease logging verbosity."
    )
    parser.add_argument("-V", "--version", action="version",
                        version="%%(prog)s %s" % hermes.__version__,
                        help="Display version information.")

    subparsers = parser.add_subparsers()

    # EVENT-TYPE COMMANDS
    # event type command line parser
    event_type_parser = subparsers.add_parser(
        "event-type", help="Create and list event types"
    )
    event_type_subparser = event_type_parser.add_subparsers()

    # event type list command line parser
    event_type_list_parser = event_type_subparser.add_parser("list")
    event_type_list_parser.set_defaults(func=list_event_types)

    # event type create command line parser
    event_type_create_parser = event_type_subparser.add_parser("create")
    event_type_create_parser.add_argument(
        "category",
        help="Category of the new event type"
    )
    event_type_create_parser.add_argument(
        "state",
        help="State of the new event type"
    )
    event_type_create_parser.add_argument(
        "-d", "--description", required=True,
        help="Human readable description for this event type"
    )
    event_type_create_parser.add_argument(
        "-r", "--restricted", action='store_true', dest='restricted',
        help=(
            "Flag this event-type as one that can only be thrown via the API, "
            "and not the WebUI or CLI"
        )
    )
    event_type_create_parser.set_defaults(func=create_event_type)

    # FATE COMMANDS
    # fate command line parser
    fate_parser = subparsers.add_parser(
        "fate", help="Create and list fates"
    )

    # fate list parser
    fate_subparser = fate_parser.add_subparsers()
    fate_list_subparser = fate_subparser.add_parser("list")
    fate_list_subparser.set_defaults(func=list_fates)

    # fate create parser
    fate_create_subparser = fate_subparser.add_parser("create")
    fate_create_subparser.add_argument(
        "-cc", "--creation-category",
        help="The category of the creation event type",
        dest="cc", type=str
    )
    fate_create_subparser.add_argument(
        "-cs", "--creation-state", help="The state of the creation event type",
        dest="cs", type=str
    )
    fate_create_subparser.add_argument(
        "-ct", "--creation-type", help="The ID of the creation type",
        dest="ct", type=str
    )
    fate_create_subparser.add_argument(
        "--follows", type=int, default=None, dest="follows_id",
        help="This Fate follows the Fate identified by ID."
    )
    fate_create_subparser.add_argument(
        "--for_owner", action='store_true',
        help="Labors created by this fate will be designated for server owners"
    )
    fate_create_subparser.add_argument(
        "--for_creator", action='store_true',
        help=(
            "Labors created by this fate will be designated for Quest creators"
        )
    )
    fate_create_subparser.add_argument(
        "--description", help="The human readable description of this fate",
        required=True
    )
    fate_create_subparser.set_defaults(func=create_fate)

    # HOST COMMANDS
    # Add host command line parser
    host_parser = subparsers.add_parser("host", help="Host level operations")
    host_subparser = host_parser.add_subparsers()

    # Host list parser
    host_list_parsers = host_subparser.add_parser("list")
    host_list_parsers.set_defaults(func=list_hosts)

    # Host add parser
    host_add_parser = host_subparser.add_parser("add")
    host_add_parser.add_argument("hostname")
    host_add_parser.set_defaults(func=add_host)

    # Host rename parser
    host_rename_parser = host_subparser.add_parser("rename")
    host_rename_parser.add_argument("oldname")
    host_rename_parser.add_argument("newname")
    host_rename_parser.set_defaults(func=rename_host)

    # Host events parsers
    host_events_parser = host_subparser.add_parser("events")
    host_events_parser.add_argument("hostname")
    host_events_parser.add_argument(
        "-l", "--limit", default=20, type=int,
        help="Limit the number of events displayed"
    )
    host_events_parser.set_defaults(func=list_host_events)

    # Host last unique events
    host_events_parser = host_subparser.add_parser("last-state")
    host_events_parser.add_argument("hostname")
    host_events_parser.set_defaults(func=list_host_last_state)

    # Host labors parser
    host_labors_parser = host_subparser.add_parser("labors")
    host_labors_parser.add_argument("hostname")
    host_labors_parser.add_argument(
        "-l", "--limit", default=20, type=int,
        help="Limit the number of labors displayed"
    )
    host_labors_parser.add_argument(
        "-v", "--verbose", default=False, action="store_true",
        help="Display verbose information"
    )
    host_labors_parser.add_argument(
        "--tags", default=False, action="store_true",
        help="Show host tags"
    )
    host_labors_parser.set_defaults(func=list_host_labors)

    # Host monitoring plugin output
    host_monitoring_parser = host_subparser.add_parser("monitoring")
    host_monitoring_parser.add_argument("hostname")
    host_monitoring_parser.set_defaults(func=list_host_labors_monitoring)

    # LABOR COMMANDS
    # labors command line parser
    labor_parser = subparsers.add_parser(
        "labor", help="List labors"
    )
    labor_subparser = labor_parser.add_subparsers()
    labor_list_parser = labor_subparser.add_parser("list")
    labor_list_parser.add_argument(
        "-l", "--limit", default=20, type=int,
        help="Limit the number of labors displayed"
    )
    labor_list_parser.add_argument(
        "--query", type=str,
        help="Query for hosts with a search string"
    )
    labor_list_parser.add_argument(
        "--user", type=str,
        help="Query for hosts by user responsible"
    )
    labor_list_parser.add_argument(
        "-v", "--verbose", default=False, action="store_true",
        help="Display verbose information"
    )
    labor_list_parser.add_argument(
        "--tags", default=False, action="store_true",
        help="Show host tags"
    )
    labor_list_parser.set_defaults(func=list_labors)

    # EVENTS COMMANDS
    # events command line parser
    event_parser = subparsers.add_parser(
        "event", help="Create and list events"
    )
    event_subparser = event_parser.add_subparsers()
    event_create_parser = event_subparser.add_parser("create")
    event_create_parser.add_argument("category")
    event_create_parser.add_argument("state")
    event_create_parser.add_argument(
        "-n", "--note", type=str, help="Note to attach to the Event"
    )
    event_create_parser.add_argument(
        "--host", "--hostname", type=str, dest="hostname",
        help="Host for which to create this Event"
    )
    event_create_parser.add_argument(
        "--query", type=str,
        help="Query for Hosts for which to create this Event"
    )
    event_create_parser.add_argument(
        "--quest-id", type=str, dest="quest_id",
        help="Create Events for each of the Hosts in this Quest"
    )
    event_create_parser.set_defaults(func=create_event)

    # PING COMMANDS
    # monitoring ping command line parser
    ping_parser = subparsers.add_parser(
        "ping", help="Perform a ping of the Hermes API server"
    )
    ping_parser.set_defaults(func=ping_server)

    # QUEST COMMANDS
    # quest command line parser
    quest_parser = subparsers.add_parser(
        "quest", help="Create and list Quests"
    )
    quest_subparser = quest_parser.add_subparsers()

    # quest list parser
    quest_list_parser = quest_subparser.add_parser("list")
    quest_list_parser.add_argument(
        "--user",
        help="Filter the list of Quests to those created by the given user"
    )
    quest_list_parser.add_argument(
        "--hosts", type=str,
        help="Filter Quests to those relating to Hosts, separated by comma"
    )
    quest_list_parser.add_argument(
        "--query", type=str,
        help="Filter Quests to those relating to Hosts return by query"
    )
    quest_list_parser.set_defaults(func=list_quests)

    # quest show parser
    quest_show_parser = quest_subparser.add_parser("show")
    quest_show_parser.add_argument("quest_id")
    quest_show_list_options = quest_show_parser.add_mutually_exclusive_group()
    quest_show_list_options.add_argument(
        "--all", action="store_true",
        help="Show all associated labors"
    )
    quest_show_list_options.add_argument(
        "--completed", action="store_true", dest="completed_only",
        help="Show only completed labors"
    )
    quest_show_parser.add_argument(
        "--list", dest="list_only", action="store_true",
        help="Only output a list of hostnames with open labors"
    )
    quest_show_parser.set_defaults(func=show_quest)

    # quest creation parser
    quest_create_parser = quest_subparser.add_parser(
        "create",
        description="To create a Hermes Quest, one should first decide two "
                    "things: (1) what hosts will be part of this Quest, "
                    "and (2) what Fate will start the Labors for the hosts"
                    "in the the Quest.\n"
                    "\n"
                    "Hosts can be specified by a query string sent to an "
                    "external source of record.  Check with your Hermes "
                    "administrator for more information.\n"
                    "\n"
                    "To pick the proper Fate ID, use `hermes fate list` "
                    "and pick an ID designated with a *."
    )
    quest_create_parser.add_argument(
        "--fate-id", type=int, dest="fate_id",
        help="The ID of the Fate that will create the starting Labors"
    )
    quest_create_parser.add_argument(
        "--due", type=str, metavar='YYYY-MM-DD HH:MM',
        help="Target date as YYYY-MM-DD HH:MM, with hours and minutes optional"
    )
    quest_create_parser.add_argument(
        "-d", "--description", type=str, required=True,
        help="Description to attach to the Quest"
    )
    quest_create_parser.add_argument(
        "--hosts", type=str,
        help="Comma separated Hosts involved in this Quest"
    )
    quest_create_parser.add_argument(
        "--query", type=str,
        help="Query for hosts with a search string"
    )
    quest_create_parser.set_defaults(func=create_quest)

    # quest editing parser
    quest_edit_parser = quest_subparser.add_parser(
        "edit",
        description="Edit an existing open Hermes Quest.  You can change the "
                    "creator if someone else should now be responsible, or you"
                    "can update the description or target date and time."
    )
    quest_edit_parser.add_argument(
        "quest_id", type=int,
        help="The ID of the Quest to edit"
    )
    quest_edit_parser.add_argument(
        "-d", "--description", type=str, dest="desc",
        help="A new description for the Quest"
    )
    quest_edit_parser.add_argument(
        "-c", "--creator", type=str, dest="creator",
        help="The new creator who will now own this Quest"
    )
    quest_edit_parser.add_argument(
        "--due", type=str, metavar='YYYY-MM-DD HH:MM',
        help=(
            "New target date as YYYY-MM-DD HH:MM, "
            "with hours and minutes optional"
        )
    )
    quest_edit_parser.set_defaults(func=edit_quest)

    return parser.parse_args()


def main():
    args = parse_cli_args()
    settings.update_from_config(args.config)

    if args.hermes_server:
        settings.hermes_server = args.hermes_server

    if args.debug:
        logging.basicConfig(level=logging.DEBUG, format=settings.log_format)
    elif args.quiet:
        logging.basicConfig(level=logging.ERROR, format=settings.log_format)
    else:
        logging.basicConfig(level=logging.INFO, format=settings.log_format)

    args.func(args)


if __name__ == "__main__":
    main()
