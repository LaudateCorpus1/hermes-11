#!/usr/bin/env python

""" Command-line interface to Hermes."""

from __future__ import division

import argparse
import getpass
import logging
import sys
import requests

from sqlalchemy import desc

import hermes
from hermes import models
from hermes.models import Event, EventType, Host, Fate, Labor, Quest
from hermes.settings_client import settings

sa_log = logging.getLogger("sqlalchemy.engine.base.Engine")
logging.getLogger("requests").setLevel(logging.WARNING)


def request_get(path):
    """Make an HTTP GET request for the given path

    Args:
        path: the full path to the resource
    Returns:
        the http response
    """
    response = requests.get(settings.hermes_server + path)

    if response.status_code != requests.codes.ok:
        sys.exit("Error: {}".format(response.json()["error"]["message"]))

    return response


def request_post(path, json):
    """Make an HTTP POST request for the given path

    If a non-OK status is returned, display the error message and exit

    Args:
        path: the full path to the resource
        json: the json to send in the body
    Returns:
        the http response
    """
    response = requests.post(settings.hermes_server + path, json=json)

    if response.status_code != requests.codes.created:
        sys.exit("Error: {}".format(response.json()["error"]["message"]))

    return response


def list_event_types(args):
    logging.debug("list_event_types()")

    response = request_get("/api/v1/eventtypes")

    event_types = response.json()

    max_length = 0
    for event_type in event_types["eventTypes"]:
        if len(str(event_type["id"])) > max_length:
            max_length = len(str(event_type["id"]))

    print"{}{}{}".format(
        str.ljust("ID", max_length + 3),
        str.ljust("CATEGORY", 20), str.ljust("STATE", 20)
    )
    for event_type in event_types["eventTypes"]:
        print "{}{}{}".format(
            str.ljust("[" + str(event_type["id"]) + "]", max_length + 3),
            str.ljust(str(event_type["category"]), 20),
            str.ljust(str(event_type["state"]), 20)
        )


def create_event_type(args):
    logging.debug("create_event_type({},{})", args.category, args.state)

    json = {
        "category": args.category,
        "state": args.state,
        "description": args.description
    }

    response = request_post("/api/v1/eventtypes", json)

    if response.json()["status"] == "created":
        print "Created event type {}".format(response.json()["id"])
    else:
        sys.exit(
            "Received unexpected status {}".format(response.json()["status"])
        )


def list_fates(args):
    logging.debug("list_fates()")

    response = request_get("/api/v1/fates")
    fates = response.json()["fates"]

    response = request_get("/api/v1/eventtypes")
    event_types = response.json()["eventTypes"]

    print "FATES  ([id] created by => completed by)\n "
    for fate in fates:
        creation_event = None
        completion_event = None
        for event_type in event_types:
            if event_type["id"] == fate['creationEventTypeId']:
                creation_event = event_type
            if event_type["id"] == fate['completionEventTypeId']:
                completion_event = event_type

        print "[{}] {} => {}".format(
            fate["id"],
            creation_event["category"] + "-" + creation_event["state"],
            completion_event["category"] + "-" + completion_event["state"]
        )
        print fate["description"]
        print ""


def create_fate(args):
    logging.debug("create_fates()")
    if not args.ct and not (args.cc and args.cs):
        print (
            "To create a fate, you must specify either --creation-type,\nor "
            "--creation-category and creation-state."
        )
        return
    if not args.xt and not (args.xc and args.xs):
        print (
            "To create a fate, you must specify either --completion-type,\nor "
            "--completion-category and completion-state."
        )
        return

    response = request_get("/api/v1/eventtypes")
    event_types = response.json()["eventTypes"]

    creation_event_type = None
    completion_event_type = None
    for event_type in event_types:

        if args.cc == event_type["category"] \
                and args.cs == event_type["state"]:
            creation_event_type = event_type
        elif args.ct == event_type["id"]:
            creation_event_type = event_type

        if args.xc == event_type["category"] \
                and args.xs == event_type["state"]:
            completion_event_type = event_type
        elif args.xt == event_type["id"]:
            completion_event_type = event_type

    if not creation_event_type:
        print "Creation event type not found."
        return

    if not completion_event_type:
        print "Completion event type not found."
        return

    json = {
        "creationEventTypeId": creation_event_type["id"],
        "completionEventTypeId": completion_event_type["id"],
        "intermediate": args.intermediate,
        "description": args.description
    }

    response = request_post("/api/v1/fates", json)

    if response.json()["status"] == "created":
        print "Created fate {}".format(response.json()["id"])
    else:
        sys.exit(
            "Received unexpected status {}".format(response.json()["status"])
        )


def list_hosts(args):
    logging.debug("list_hosts()")
    response = request_get("/api/v1/hosts")
    hosts = response.json()["hosts"]
    print "HOSTS:"
    for host in hosts:
        print "{}".format(host["hostname"])


def add_host(args):
    logging.debug("add_host(%s)", args.hostname)
    response = request_get("/api/v1/hosts?hostname={}".format(args.hostname))
    hosts = response.json()

    if hosts["totalHosts"] > 0:
        sys.exit("Host {} already exists".format(args.hostname))

    json = {
        "hostname": args.hostname
    }

    response = request_post("/api/v1/hosts", json)

    if response.json()["status"] == "created":
        print "Created host {}".format(response.json()["hostname"])
    else:
        sys.exit(
            "Received unexpected status {}".format(response.json()["status"])
        )


def list_host_events(args):
    logging.debug("list_host_events(%s)", args.hostname)

    response = request_get(
        "/api/v1/hosts/{}?expand=events&expand=eventtypes".format(
            args.hostname
        )
    )

    host = response.json()
    events = host["events"]

    print "EVENTS FOR {}:".format(host["hostname"])
    for event in events:
        print "{}  {} {}  {}".format(
            event["timestamp"], event["eventType"]["category"],
            event["eventType"]["state"], event["note"]
        )


def list_host_labors(args):
    logging.debug("list_host_labors(%s)", args.hostname)

    response = request_get(
        "/api/v1/hosts/{}?expand=labors&expand=events&expand=eventtypes".format(
            args.hostname
        )
    )

    host = response.json()
    labors = host["labors"]

    print "OPEN LABORS FOR {}:".format(host["hostname"])
    for labor in labors:
        print "[{}] created {} by event {} {}  {}".format(
            labor["id"],
            labor["creationTime"],
            labor["creationEvent"]["eventType"]["category"],
            labor["creationEvent"]["eventType"]["state"],
            labor["creationEvent"]["note"] or ""
        )


def create_event(args):
    logging.debug("create_event()")
    logging.debug(
        "host: %s    category: %s    state: %s    note: %s",
        args.hostname, args.category, args.state, args.note
    )

    session = make_session()

    event_type = EventType.get_event_type(session, args.category, args.state)

    if event_type is None:
        logging.error(
            "No matching event state found for %s %s", args.category, args.state
        )
        session.close()
        return

    host = Host.get_host(session, args.hostname)

    if host is None:
        host = Host.create(session, args.hostname)

    user = getpass.getuser()

    event = Event.create(session, host, user, event_type, args.note)

    if event:
        print "Event created: {} => {} {}".format(
            host.hostname, event_type.category, event_type.state
        )
        session.commit()
    else:
        print "Event creation failed."
        session.rollback()

    session.close()


def list_quests(args):
    logging.debug("list_quests()")
    session = make_session()

    quests = Quest.get_open_quests(session).all()

    print "QUESTS:"
    for quest in quests:
        print "[{}] {} by {}.  Embarked on {}".format(
            quest.id, quest.description, quest.creator, quest.embark_time
        )

        labors_remaining = 0
        for labor in quest.labors:
            if labor.completion_time is None:
                labors_remaining += 1

        total_labors = len(quest.labors)
        print "{:.2%} complete.  {} total labors.  {} remain open.\n".format(
            (total_labors - labors_remaining)/total_labors,
            total_labors,
            labors_remaining
        )

    session.close()


def show_quest(args):
    logging.debug("show_quest(%d)", args.quest_id)
    session = make_session()

    quest = session.query(Quest).get(args.quest_id)

    max_width = 0
    for labor in quest.labors:
        if len(labor.host.hostname) > max_width:
            max_width = len(labor.host.hostname)

    remaining = []
    completed = []
    for labor in quest.labors:
        if labor.completion_time is None:
            remaining.append(labor)
        else:
            completed.append(labor)

    if not args.list_only:
        print "QUEST {}:".format(args.quest_id)
        print "{} by {}.  Embarked on {}".format(
            quest.description, quest.creator, quest.embark_time
        )

        if args.all or args.completed_only:
            for labor in completed:
                print "{} achieved {} {} on {}".format(
                    labor.host.hostname.rjust(max_width + 4),
                    labor.creation_event.event_type.category,
                    labor.creation_event.event_type.state,
                    labor.completion_time
                )
        if not args.completed_only:
            for labor in remaining:
                print "{} must achieve {} {}".format(
                    labor.host.hostname.rjust(max_width + 4),
                    labor.creation_event.event_type.category,
                    labor.creation_event.event_type.state
                )

        total_labors = len(quest.labors)
        labors_remaining = len(remaining)
        labors_completed = len(completed)
        print "{:.2%} complete.  {} total labors.  {} remain open.\n".format(
            labors_completed/total_labors,
            total_labors,
            labors_remaining
        )
    else:
        if args.completed_only or args.all:
            for labor in completed:
                print labor.host.hostname
        if not args.completed_only:
            for labor in remaining:
                print labor.host.hostname

    session.close()


def create_quest(args):
    logging.debug("create_quest()")
    logging.debug(
        "category: %s    state: %s    note: %s",
        args.category, args.state, args.note
    )

    session = make_session()

    print "Creating quest... (could take some time)"

    hosts = []

    if args.hosts:
        for hostname in args.hosts.split(","):
            if not hostname:
                continue
            logging.debug("Specified host: %s", hostname)
            host = Host.get_host(session, hostname)
            if host is None:
                Host.create(session, hostname)
            hosts.append(hostname)
    else:
        for hostname in sys.stdin.read().split("\n"):
            if not hostname:
                continue
            logging.debug("Entered host: %s", hostname)
            host = Host.get_host(session, hostname)
            if host is None:
                Host.create(session, hostname)
            hosts.append(hostname)

    if len(hosts) == 0:
        logging.error("No hosts specified")
        return

    event_type = EventType.get_event_type(session, args.category, args.state)
    if event_type is None:
        logging.error(
            "No matching event state found for %s %s", args.category, args.state
        )
        session.close()
        return

    user = getpass.getuser()

    quest = Quest.create(session, user, hosts, event_type, description=args.note)

    print "Quest {} created with {} labors".format(
        quest.id, len(quest.labors)
    )

    session.commit()
    session.close()


def parse_cli_args():
    description_msg = "Hermes CLI"
    parser = argparse.ArgumentParser(description=description_msg)

    parser.add_argument("-c", "--config", default="/etc/hermes.yaml",
                        help="Path to config file.")
    parser.add_argument(
        "-s", "--server", dest="hermes_server"
    )
    parser.add_argument(
        "-v", "--verbose", action="count", default=0,
        help="Increase logging verbosity."
    )
    parser.add_argument(
        "-q", "--quiet", action="count", default=0,
        help="Decrease logging verbosity."
    )
    parser.add_argument("-V", "--version", action="version",
                        version="%%(prog)s %s" % hermes.__version__,
                        help="Display version information.")

    subparsers = parser.add_subparsers()

    # event type command line parser
    event_type_parser = subparsers.add_parser(
        "event-type", help="Create and list event types"
    )
    event_type_subparser = event_type_parser.add_subparsers()
    # event type list command line parser
    event_type_list_parser = event_type_subparser.add_parser("list")
    event_type_list_parser.set_defaults(func=list_event_types)
    # event type create command line parser
    event_type_create_parser = event_type_subparser.add_parser("create")
    event_type_create_parser.add_argument(
        "category",
        help="Category of the new event type"
    )
    event_type_create_parser.add_argument(
        "state",
        help="State of the new event type"
    )
    event_type_create_parser.add_argument(
        "-d", "--description", required=True,
        help="Human readable description for this event type"
    )
    event_type_create_parser.set_defaults(func=create_event_type)

    # fate command line parser
    fate_parser = subparsers.add_parser(
        "fate", help="Create and list fates"
    )
    # fate list parser
    fate_subparser = fate_parser.add_subparsers()
    fate_list_subparser = fate_subparser.add_parser("list")
    fate_list_subparser.set_defaults(func=list_fates)
    # fate create parser
    fate_create_subparser = fate_subparser.add_parser("create")
    fate_create_subparser.add_argument(
        "-cc", "--creation-category", help="The category of the creation event type",
        dest="cc", type=str
    )
    fate_create_subparser.add_argument(
        "-cs", "--creation-state", help="The state of the creation event type",
        dest="cs", type=str
    )
    fate_create_subparser.add_argument(
        "-ct", "--creation-type", help="The ID of the creation type",
        dest="ct", type=str
    )
    fate_create_subparser.add_argument(
        "-xc", "--completion-category",
        help="The category of the completion event type",
        dest="xc", type=str
    )
    fate_create_subparser.add_argument(
        "-xs", "--completion-state", help="The state of the completion event type",
        dest="xs", type=str
    )
    fate_create_subparser.add_argument(
        "-xt", "--completion-type", help="The ID of the completion event type",
        dest="xt", type=str
    )
    fate_create_subparser.add_argument(
        "-i", "--intermediate", action="store_true",
        help="When flagged, this fate only creates a new labor if closing an existing one"
    )
    fate_create_subparser.add_argument(
        "--description", help="The human readable description of this fate",
        required=True
    )
    fate_create_subparser.set_defaults(func=create_fate)

    # Add host command line parser
    host_parser = subparsers.add_parser("host", help="Host level operations")
    host_subparser = host_parser.add_subparsers()
    # Host list parser
    host_list_parsers = host_subparser.add_parser("list")
    host_list_parsers.set_defaults(func=list_hosts)
    # Host add parser
    host_add_parser = host_subparser.add_parser("add")
    host_add_parser.add_argument("hostname")
    host_add_parser.set_defaults(func=add_host)
    # Host events parsers
    host_events_parser = host_subparser.add_parser("events")
    host_events_parser.add_argument("hostname")
    host_events_parser.add_argument(
        "-l", "--limit", default=20, type=int,
        help="Limit the number of events displayed"
    )
    host_events_parser.set_defaults(func=list_host_events)
    # Host labors parser
    host_labors_parser = host_subparser.add_parser("labors")
    host_labors_parser.add_argument("hostname")
    host_labors_parser.add_argument(
        "-l", "--limit", default=20, type=int,
        help="Limit the number of labors displayed"
    )
    host_labors_parser.set_defaults(func=list_host_labors)

    # events command line parser
    event_parser = subparsers.add_parser(
        "event", help="Create and list events"
    )
    event_subparser = event_parser.add_subparsers()
    event_create_parser = event_subparser.add_parser("create")
    event_create_parser.add_argument("hostname")
    event_create_parser.add_argument("category")
    event_create_parser.add_argument("state")
    event_create_parser.add_argument(
        "-n", "--note", type=str, help="Note to attach to the Event"
    )
    event_create_parser.set_defaults(func=create_event)

    # quest command line parser
    quest_parser = subparsers.add_parser(
        "quest", help="Create and list Quests"
    )
    quest_subparser = quest_parser.add_subparsers()
    # quest list parser
    quest_list_parser = quest_subparser.add_parser("list")
    quest_list_parser.set_defaults(func=list_quests)
    # quest show parser
    quest_show_parser = quest_subparser.add_parser("show")
    quest_show_parser.add_argument("quest_id")
    quest_show_list_options = quest_show_parser.add_mutually_exclusive_group()
    quest_show_list_options.add_argument(
        "--all", action="store_true",
        help="Show all associated labors"
    )
    quest_show_list_options.add_argument(
        "--completed", action="store_true", dest="completed_only",
        help="Show only completed labors"
    )
    quest_show_parser.add_argument(
        "--list", dest="list_only", action="store_true",
        help="Only output a list of hostnames with open labors"
    )
    quest_show_parser.set_defaults(func=show_quest)
    # quest creation parser
    quest_create_parser = quest_subparser.add_parser("create")
    quest_create_parser.add_argument("category")
    quest_create_parser.add_argument("state")
    quest_create_parser.add_argument(
        "-n", "--note", type=str, required=True,
        help="Note to attach to the Quest"
    )
    quest_create_parser.add_argument(
        "--hosts", type=str,
        help="Comma separated Hosts involved in this Quest"
    )
    quest_create_parser.set_defaults(func=create_quest)

    return parser.parse_args()


def main():
    args = parse_cli_args()
    settings.update_from_config(args.config)

    if args.hermes_server:
        settings.hermes_server = args.hermes_server

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG, format=settings.log_format)
    elif args.quiet:
        logging.basicConfig(level=logging.ERROR, format=settings.log_format)
    else:
        logging.basicConfig(level=logging.INFO, format=settings.log_format)

    args.func(args)


if __name__ == "__main__":
    main()
